// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  first_name      String
  last_name       String
  email           String    @unique
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?
  role            UserRole  @default(recruiter)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  jobs           Job[]
  AssistantEvent AssistantEvent[]
  Thread         Thread[]
  AssistantTask  AssistantTask[]
  Template       Template[]
  Settings       Settings[]
  Meeting        Meeting[]
  Account        Account[]
  Session        Session[]
}

model Job {
  id           String    @id @default(cuid())
  user         User      @relation(fields: [recruiter_id], references: [id])
  recruiter_id String
  client       Client?   @relation(fields: [client_id], references: [id])
  client_id    String?
  title        String
  description  String
  status       JobStatus @default(active)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  candidates     Candidate[]
  AssistantEvent AssistantEvent[]
  Thread         Thread[]
  AssistantTask  AssistantTask[]
  Template       Template[]
  Meeting        Meeting[]
}

model Candidate {
  id              String           @id @default(cuid())
  job_id          String
  job             Job              @relation(fields: [job_id], references: [id])
  name            String
  email           String?
  source          Sources
  status          CandidateStatus  @default(awaiting_reply)
  last_contact_at DateTime?
  created_at      DateTime         @default(now())
  updated_at      DateTime         @updatedAt
  AssistantEvent  AssistantEvent[]
  Thread          Thread[]
  AssistantTask   AssistantTask[]
  Meeting         Meeting[]

  @@index([email])
}

model Client {
  id   String @id @default(cuid())
  name String

  jobs Job[]
}

enum UserRole {
  recruiter
  admin
}

enum JobStatus {
  active
  paused
  closed
}

enum Sources {
  email
  linkedIn
}

enum CandidateStatus {
  new_contact
  awaiting_reply
  availability_detected
  scheduled
  rejected
  advanced
}

model AssistantEvent {
  id              String      @id @default(cuid())
  recruiter_id    String
  recruiter       User        @relation(fields: [recruiter_id], references: [id])
  job_id          String?
  job             Job?        @relation(fields: [job_id], references: [id])
  candidate_id    String?
  candidate       Candidate?  @relation(fields: [candidate_id], references: [id])
  type            EventType
  source          EventSource
  payload_summary String
  raw_payload_ref String?
  action_taken    String // free text for now (log style), could convert to enum later
  createdAt       DateTime    @default(now())
}

enum EventType {
  email_received
  role_detected
  candidate_contacted
  availability_detected
  meeting_scheduled
  status_parsed
}

enum EventSource {
  email
  linkedin_notification
  ats
  manual
}

model Thread {
  id               String      @id @default(cuid())
  recruiter_id     String
  recruiter        User        @relation(fields: [recruiter_id], references: [id])
  job_id           String
  job              Job         @relation(fields: [job_id], references: [id])
  candidate_id     String
  candidate        Candidate   @relation(fields: [candidate_id], references: [id])
  email_thread_ref String
  last_state       ThreadState
  trust_level      TrustLevel  @default(draft_only)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
}

enum ThreadState {
  awaiting_reply
  scheduled
  follow_up_pending
  closed
}

enum TrustLevel {
  draft_only
  ask_to_send
  auto_send
}

model AssistantTask {
  id             String     @id @default(cuid())
  recruiter_id   String
  recruiter      User       @relation(fields: [recruiter_id], references: [id])
  job_id         String
  job            Job        @relation(fields: [job_id], references: [id])
  candidate_id   String
  candidate      Candidate  @relation(fields: [candidate_id], references: [id])
  action         TaskAction
  status         TaskStatus @default(pending)
  needs_approval Boolean    @default(true)
  proposed_time  DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
}

enum TaskAction {
  send_followup
  propose_time
  send_status_update
  create_event
}

enum TaskStatus {
  pending
  approved
  sent
  expired
  failed
}

model Template {
  id             String          @id @default(cuid())
  recruiter_id   String
  recruiter      User            @relation(fields: [recruiter_id], references: [id])
  status_trigger CandidateStatus
  job_id         String? // nullable so recruiter can set generic fallback template
  job            Job?            @relation(fields: [job_id], references: [id])
  content        String
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Settings {
  recruiter_id        String   @id
  recruiter           User     @relation(fields: [recruiter_id], references: [id])
  calendar_provider   String?
  working_hours       Json?
  auto_send_followups Boolean  @default(false)
  allowed_labels      Json?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model Meeting {
  id                 String        @id @default(cuid())
  recruiter_id       String
  recruiter          User          @relation(fields: [recruiter_id], references: [id])
  job_id             String
  job                Job           @relation(fields: [job_id], references: [id])
  candidate_id       String
  candidate          Candidate     @relation(fields: [candidate_id], references: [id])
  scheduled_time     DateTime
  calendar_event_ref String?
  status             MeetingStatus @default(scheduled)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
}

enum MeetingStatus {
  scheduled
  completed
  no_show
  cancelled
}

// Necessary for Next auth
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? // @db.Text
  access_token             String? // @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? // @db.Text
  session_state            String?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  refresh_token_expires_in Int?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
